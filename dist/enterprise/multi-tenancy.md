# Multi-Tenancy

> Use when designing multi-tenant SaaS architectures, implementing tenant isolation, data partitioning strategies, or building billing/metering systems - covers pooled, siloed, and hybrid models

**Category:** enterprise | **Version:** 1.0.0

---

## Patterns


## Anti-Patterns


## Sharp Edges (Gotchas)

*Real production issues that cause outages and bugs.*

### [CRITICAL] Database query lacks tenant_id filter allowing cross-tenant data access

**Why it happens:**
Every database query must filter by tenant_id. Without this, a query
returns data from all tenants - a severe security vulnerability.
One missing filter can expose all customer data.


**Solution:**
```
1. Use ORM middleware to auto-add tenant filter:
   - SQLAlchemy event listener
   - Django model managers
   - Prisma middleware

2. PostgreSQL Row-Level Security:
   - Enable RLS on all tables
   - Create tenant isolation policy
   - Force RLS for table owner

3. Code review checklist:
   - Every query has tenant_id
   - JOIN conditions include tenant_id
   - Subqueries filter by tenant

```

**Symptoms:**
- Users see other tenants' data
- Data counts don't match expectations
- Security audit flags data leakage

---

### [CRITICAL] Thread-local or global tenant context persists across requests

**Why it happens:**
Using global or thread-local storage for tenant context is dangerous
in async environments. If not properly cleared, one request's tenant
context leaks to another request - especially in connection pools.


**Solution:**
```
1. Use contextvars (Python) or AsyncLocalStorage (Node):
   - Request-scoped, async-safe
   - Can't leak between requests

2. Middleware must:
   - Set context at request start
   - Clear context at request end
   - Handle errors to ensure cleanup

3. Never use:
   - Global variables for tenant
   - Thread-local in async code
   - Module-level state

```

**Symptoms:**
- Random data from wrong tenant
- Intermittent cross-tenant issues
- Only happens under load

---

### [HIGH] One tenant's heavy usage impacts all other tenants

**Why it happens:**
In shared infrastructure, one tenant running expensive queries or
making excessive API calls degrades performance for everyone.
Without quotas and limits, the biggest tenant wins.


**Solution:**
```
1. Per-tenant rate limiting:
   - API request limits (requests/second)
   - Burst allowance with token bucket
   - Different limits by plan tier

2. Resource quotas:
   - CPU limits per tenant
   - Memory limits per tenant
   - Database connection limits
   - IOPS limits

3. Fair scheduling:
   - Tenant-aware query queues
   - Priority based on plan
   - Throttle heavy users

```

**Symptoms:**
- Latency spikes correlate with specific tenant activity
- Small tenants complain about slow performance
- Database CPU spikes from one tenant's queries

---

### [HIGH] Applying migrations to all tenant schemas simultaneously

**Why it happens:**
With schema-per-tenant, you have N schemas to migrate. Running them
all at once is slow, risky, and blocks rollout. One failure can
leave your database in an inconsistent state across tenants.


**Solution:**
```
1. Rolling migrations:
   - Migrate tenants in batches
   - Verify each batch before continuing
   - Pause on errors

2. Online schema changes:
   - Use pt-online-schema-change
   - Or gh-ost for MySQL
   - Minimal locking

3. Canary deployments:
   - Migrate 1% of tenants first
   - Verify application works
   - Then roll out to rest

```

**Symptoms:**
- Long downtime during migrations
- Failed migration leaves tenants inconsistent
- Can't rollback without affecting everyone

---

## Collaboration

### When to Hand Off

| Trigger | Delegate To | Context |
|---------|-------------|--------|
| `enterprise.architecture|system.design` | enterprise-architecture | Overall architecture decisions |
| `gdpr|privacy|data.deletion|right.to.erasure` | gdpr-privacy | Privacy compliance per tenant |
| `disaster.recovery|backup|tenant.restore` | disaster-recovery | Per-tenant DR strategy |
| `billing|subscription|stripe|payments` | payments | Tenant billing integration |

### Receives Work From

- **enterprise-architecture**: Multi-tenant architecture patterns
- **gdpr-privacy**: Data privacy per tenant

---

## Get the Full Version

This skill has **automated validations**, **detection patterns**, and **structured handoff triggers** that work with the Spawner orchestrator.

```bash
npx vibeship-spawner-skills install
```

Full skill path: `~/.spawner/skills/enterprise/multi-tenancy/`

**Includes:**
- `skill.yaml` - Structured skill definition
- `sharp-edges.yaml` - Machine-parseable gotchas with detection patterns
- `validations.yaml` - Automated code checks
- `collaboration.yaml` - Handoff triggers for skill orchestration

---

*Generated by [VibeShip Spawner](https://github.com/vibeforge1111/vibeship-spawner-skills)*
